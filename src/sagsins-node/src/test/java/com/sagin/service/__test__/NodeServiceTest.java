package com.sagin.service.__test__;

import com.sagin.model.*;
import com.sagin.repository.INodeRepository;
import com.sagin.service.NodeService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Collection;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Unit Test cho lớp NodeService.
 * Lớp này sử dụng Mockito để giả lập (mock) INodeRepository.
 * Mục tiêu: Chỉ test logic nghiệp vụ (tính toán, cache, flush) của NodeService.
 */
@ExtendWith(MockitoExtension.class)
class NodeServiceTest {

    // Tạo một đối tượng giả lập (mock)
    @Mock
    private INodeRepository nodeRepository;

    // Tiêm (Inject) mock 'nodeRepository' vào 'nodeService'
    @InjectMocks
    private NodeService nodeService;

    private NodeInfo testNode;
    private Packet testPacket;

    /**
     * Hàm này chạy TRƯỚC MỖI @Test
     * Dùng để khởi tạo dữ liệu test chung.
     */
    @BeforeEach
    void setUp() {
        // Khởi tạo một NodeInfo mẫu
        testNode = new NodeInfo();
        testNode.setNodeId("N1");
        testNode.setNodeType(NodeType.LEO_SATELLITE); // Giả sử bạn có enum này
        testNode.setBatteryChargePercent(50.0);
        testNode.setPacketBufferCapacity(100);
        testNode.setCurrentPacketCount(10);
        testNode.setResourceUtilization(0.2);
        testNode.setPacketLossRate(0.01);
        testNode.setOperational(true); // Quan trọng cho isHealthy()
        testNode.setWeather(WeatherCondition.CLEAR); // Quan trọng cho isHealthy()
        testNode.setCommunication(new Communication(
                12.0,  // frequencyGHz
                100.0, // bandwidthMHz (Quan trọng cho tính toán)
                30.0,  // transmitPowerDbW
                40.0,  // antennaGainDb
                2.0,   // beamWidthDeg
                2000.0, // maxRangeKm
                10.0,  // minElevationDeg
                "192.168.1.1",
                8080,
                "TCP"
        ));

        // Khởi tạo một Packet mẫu
        testPacket = new Packet();
        testPacket.setPacketId("P1");
        testPacket.setCurrentHoldingNodeId("N1");
        testPacket.setPayloadSizeByte(1024);
        testPacket.setUseRL(false); // Không dùng RL
        testPacket.setMaxAcceptableLatencyMs(200.0);
        testPacket.setAccumulatedDelayMs(10.0);
    }

    @Test
    @DisplayName("Test xử lý packet thành công (Happy Path)")
    void testUpdateNodeStatus_Successful() {
        // === 1. ARRANGE ===
        double originalBattery = testNode.getBatteryChargePercent();
        double originalAccumulatedDelay = testPacket.getAccumulatedDelayMs();

        // Định nghĩa hành vi của Mock:
        // "Khi repo.getNodeInfo("N1") được gọi, hãy trả về Optional chứa testNode"
        when(nodeRepository.getNodeInfo("N1")).thenReturn(Optional.of(testNode));

        // === 2. ACT ===
        nodeService.updateNodeStatus("N1", testPacket);

        // === 3. ASSERT ===
        // Khẳng định packet không bị drop
        assertFalse(testPacket.isDropped());
        
        // Khẳng định pin đã bị tiêu hao (pin mới < pin cũ)
        assertTrue(testNode.getBatteryChargePercent() < originalBattery);

        // Khẳng định độ trễ đã bị cộng dồn
        assertTrue(testPacket.getAccumulatedDelayMs() > originalAccumulatedDelay);

        // Khẳng định buffer count không đổi (10 -> 11 -> 10)
        assertEquals(10, testNode.getCurrentPacketCount());
    }

    @Test
    @DisplayName("Test xử lý packet bị drop do BUFFER_OVERFLOW")
    void testUpdateNodeStatus_BufferOverflow() {
        // === 1. ARRANGE ===
        // Sửa đổi node cho trường hợp này: buffer đầy
        testNode.setCurrentPacketCount(100); // Đầy (100/100)
        when(nodeRepository.getNodeInfo("N1")).thenReturn(Optional.of(testNode));

        // === 2. ACT ===
        nodeService.updateNodeStatus("N1", testPacket);

        // === 3. ASSERT ===
        // Khẳng định packet ĐÃ BỊ drop
        assertTrue(testPacket.isDropped());
        // Đây là khẳng định mấu chốt. Nó sẽ PASS sau khi bạn sửa NodeService.
        assertEquals("BUFFER_OVERFLOW_AT_N1", testPacket.getDropReason());

        // Khẳngđịnh service đã gọi repo để LƯU LẠI (vì loss rate thay đổi)
        nodeService.flushToDatabase();
        
        // Khẳng định rằng repo ĐÃ ĐƯỢC GỌI để lưu node (với loss rate mới)
        verify(nodeRepository, times(1)).bulkUpdateNodes(any());
    }
    
    @Test
    @DisplayName("Test xử lý packet bị drop do QOS_LATENCY_EXCEEDED")
    void testUpdateNodeStatus_LatencyExceeded() {
        // === 1. ARRANGE ===
        // Sửa đổi packet: đã gần hết hạn latency
        testPacket.setAccumulatedDelayMs(199.0); // Giả sử tính toán ra 2.0ms
        testPacket.setMaxAcceptableLatencyMs(200.0); // Ngưỡng là 200
        
        when(nodeRepository.getNodeInfo("N1")).thenReturn(Optional.of(testNode));

        // === 2. ACT ===
        nodeService.updateNodeStatus("N1", testPacket);

        // === 3. ASSERT ===
        // Khẳng định packet ĐÃ BỊ drop
        assertTrue(testPacket.isDropped());
        assertEquals("QOS_LATENCY_EXCEEDED", testPacket.getDropReason());
    }

    @Test
    @DisplayName("Test flushToDatabase gọi bulkUpdateNodes chính xác")
    void testFlushToDatabase_CallsBulkUpdateCorrectly() {
        // === 1. ARRANGE ===
        when(nodeRepository.getNodeInfo("N1")).thenReturn(Optional.of(testNode));

        // === 2. ACT ===
        nodeService.updateNodeStatus("N1", testPacket);
        nodeService.flushToDatabase();

        // === 3. ASSERT ===
        // Tạo một ArgumentCaptor để "bắt" tham số được truyền đi
        @SuppressWarnings("unchecked")
        ArgumentCaptor<Collection<NodeInfo>> captor = (ArgumentCaptor<Collection<NodeInfo>>) (Object)
                ArgumentCaptor.forClass(Collection.class);

        // Khẳng định rằng repo.bulkUpdateNodes ĐÃ ĐƯỢC GỌI 1 lần
        verify(nodeRepository, times(1)).bulkUpdateNodes(captor.capture());

        // Phân tích tham số đã bị bắt
        Collection<NodeInfo> flushedNodes = captor.getValue();
        assertEquals(1, flushedNodes.size()); // Phải có 1 node
        assertEquals("N1", flushedNodes.iterator().next().getNodeId()); // Phải là N1
        assertTrue(flushedNodes.iterator().next().getBatteryChargePercent() < 50.0); // Phải là node đã bị sửa
    }

    @Test
    @DisplayName("Test flushToDatabase không làm gì khi không có thay đổi")
    void testFlushToDatabase_NoChanges() {
        // === 1. ARRANGE ===
        // Không làm gì cả

        // === 2. ACT ===
        nodeService.flushToDatabase();

        // === 3. ASSERT ===
        // Khẳng định rằng repo.bulkUpdateNodes KHÔNG BAO GIỜ được gọi
        verify(nodeRepository, never()).bulkUpdateNodes(any());
    }
    
    @Test
    @DisplayName("Test processTick xử lý nhiều packet và flush 1 lần")
    void testProcessTick_MultiplePackets() {
        // === 1. ARRANGE ===
        // Tạo Node 2 và Packet 2
        NodeInfo node2 = new NodeInfo();
        node2.setNodeId("N2");
        node2.setNodeType(NodeType.GEO_SATELLITE); // Giả sử
        node2.setBatteryChargePercent(99.0);
        node2.setPacketBufferCapacity(100);
        node2.setCurrentPacketCount(10);
        node2.setOperational(true); // đảm bảo isHealthy() = true
        node2.setWeather(WeatherCondition.CLEAR);
        node2.setCommunication(testNode.getCommunication()); // Dùng chung

        Packet packet2 = new Packet();
        packet2.setPacketId("P2");
        packet2.setCurrentHoldingNodeId("N2");
        packet2.setPayloadSizeByte(512);
        packet2.setUseRL(true); // Packet này dùng RL
        packet2.setMaxAcceptableLatencyMs(500.0);
        packet2.setAccumulatedDelayMs(20.0);


        List<Packet> packets = List.of(testPacket, packet2);
        
        // Mock repo cho cả 2 node
        when(nodeRepository.getNodeInfo("N1")).thenReturn(Optional.of(testNode));
        when(nodeRepository.getNodeInfo("N2")).thenReturn(Optional.of(node2));

        // === 2. ACT ===
        // nodeMap bị bỏ qua, nên ta truyền null
        nodeService.processTick(null, packets); 
        nodeService.flushToDatabase();

        // === 3. ASSERT ===
        // Khẳng định cả 2 node đều bị tiêu hao pin
        assertTrue(testNode.getBatteryChargePercent() < 50.0);
        assertTrue(node2.getBatteryChargePercent() < 99.0);
        
        // Khẳng định repo.bulkUpdateNodes được gọi 1 lần với 2 node
        @SuppressWarnings("unchecked")
        ArgumentCaptor<Collection<NodeInfo>> captor = (ArgumentCaptor<Collection<NodeInfo>>) (Object)
                ArgumentCaptor.forClass(Collection.class);
        verify(nodeRepository, times(1)).bulkUpdateNodes(captor.capture());
        
        assertEquals(2, captor.getValue().size()); // Phải flush 2 node
    }
}